"""LangGraph-based diagram service with full backward compatibility."""

from __future__ import annotations

import uuid
from typing import Any, Dict, Tuple

from app.core.config import Settings
from app.core.langgraph_config import LangGraphConfig, create_initial_state
from app.core.logging import get_logger
from app.workflows.state import DiagramWorkflowState

__all__ = ["LangGraphDiagramService"]

logger = get_logger(__name__)


class LangGraphDiagramService:
    """LangGraph-based diagram service with full backward compatibility.

    This service implements the same interface as the original DiagramService
    but uses LangGraph workflows internally for state management and execution.
    """

    def __init__(self, settings: Settings) -> None:
        self.settings = settings

        # Initialize LangGraph configuration
        self.langgraph_config = LangGraphConfig(settings)

        # Create and compile the workflow
        workflow_graph = self.langgraph_config.create_workflow()
        self.workflow = self.langgraph_config.compile_workflow(workflow_graph)

        logger.info("LangGraph diagram service initialized")

    async def generate_diagram_from_description(
        self, description: str
    ) -> Tuple[str, Dict[str, Any]]:
        """Generate diagram using LangGraph workflow - same interface as original.

        Args:
            description: Natural language description of the diagram

        Returns:
            Tuple of (base64_image, metadata) matching original service contract
        """
        logger.info(
            "Starting LangGraph diagram generation (desc_len=%d)",
            len(description),
        )

        # Create initial workflow state
        initial_state = create_initial_state(description, self.settings)

        try:
            # Execute the workflow
            final_state = await self.workflow.ainvoke(
                initial_state,
                config={
                    "configurable": {"thread_id": initial_state["request_id"]},
                    "recursion_limit": 50,  # Increase for complex workflows
                },
            )

            # Extract results in original format
            final_image = self._extract_final_image(final_state)
            metadata = self._format_metadata(final_state)

            logger.info(
                "LangGraph generation completed (request_id=%s, has_image=%s, errors=%d)",
                final_state["request_id"],
                bool(final_image),
                len(final_state.get("errors", [])),
            )

            return final_image, metadata

        except Exception as e:
            logger.error(
                "LangGraph workflow execution failed: %s",
                e,
                exc_info=True,
            )
            raise

    def _extract_final_image(self, state: DiagramWorkflowState) -> str:
        """Extract final image from workflow state.

        Args:
            state: Final workflow state

        Returns:
            Base64 encoded image string

        Raises:
            ValueError: If no image is available
        """
        # Use adjusted image if available, otherwise use before image
        final_image = state.get("image_after") or state.get("image_before")

        if not final_image:
            raise ValueError("No image generated by workflow")

        return final_image

    def _format_metadata(self, state: DiagramWorkflowState) -> Dict[str, Any]:
        """Format metadata to match original service contract.

        Args:
            state: Final workflow state

        Returns:
            Metadata dictionary matching original format
        """
        # Get final metadata from finalize node
        final_metadata = state.get("final_metadata", {})

        if final_metadata:
            # Finalize node already formatted the metadata
            return final_metadata

        # Fallback: format metadata manually if finalize didn't run
        analysis = state.get("analysis")
        timing_data = state.get("timing", {})

        return {
            "nodes_created": len(analysis.nodes) if analysis and analysis.nodes else 0,
            "clusters_created": len(analysis.clusters)
            if analysis and analysis.clusters
            else 0,
            "connections_made": len(analysis.connections)
            if analysis and analysis.connections
            else 0,
            "generation_time": sum(timing_data.values()),
            "timing": {
                "analysis_s": timing_data.get("analysis_s", 0.0),
                "render_s": timing_data.get("render_s", 0.0)
                + timing_data.get("adjust_render_s", 0.0),
                "total_s": sum(timing_data.values()),
            },
            "analysis_method": state.get("analysis_method", "unknown"),
            "critique_applied": bool(state.get("image_after")),
            "request_id": state["request_id"],
            "errors": state.get("errors", []),
            **state.get("metadata", {}),
        }

    async def generate_diagram_with_critique(
        self, description: str
    ) -> Tuple[Tuple[str, str | None], Dict[str, Any]]:
        """Generate diagram with critique - compatibility method.

        This method provides compatibility with the existing critique workflow
        interface while using the LangGraph implementation internally.

        Args:
            description: Natural language description

        Returns:
            Tuple of ((image_before, image_after), metadata)
        """
        logger.info(
            "Starting LangGraph critique generation (desc_len=%d)",
            len(description),
        )

        # Create initial state with critique enabled
        initial_state = create_initial_state(description, self.settings)
        initial_state["critique_enabled"] = True

        # Execute workflow
        final_state = await self.workflow.ainvoke(
            initial_state,
            config={"configurable": {"thread_id": initial_state["request_id"]}},
        )

        # Extract before/after images
        image_before = final_state.get("image_before")
        image_after = final_state.get("image_after")

        # Format metadata
        metadata = self._format_metadata(final_state)

        logger.info(
            "LangGraph critique generation completed (before=%s, after=%s)",
            bool(image_before),
            bool(image_after),
        )

        return (image_before, image_after), metadata
